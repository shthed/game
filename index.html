<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Vector World — Babylon</title>
  <style>
    html, body { height: 100%; margin: 0; background: #87ceeb; touch-action: none; }
    #renderCanvas { width: 100%; height: 100%; display: block; cursor: crosshair; }
    #tests { position:fixed; left:10px; bottom:10px; z-index:7; background:rgba(0,0,0,.65); color:#e6edf3; padding:6px 8px; border-radius:8px; font:12px system-ui; white-space:pre; max-width:60vw; max-height:30vh; overflow:auto; }

    #optsBtn { position: fixed; right: 12px; top: 12px; z-index: 8; border: 0; padding: 10px 12px; border-radius: 10px; background: rgba(0,0,0,.65); color: #fff; font: 14px/1 system-ui; cursor: pointer; }
    #panel { position: fixed; right: 12px; top: 52px; z-index: 9; width: min(380px, 92vw); max-height: 80vh; overflow: auto; padding: 14px; border-radius: 12px; backdrop-filter: blur(6px); background: rgba(10,12,20,.85); color:#e6edf3; font: 13px system-ui; display: none; }
    #panel h3 { margin: 6px 0 8px; font-size: 14px; color: #bcd; }
    #panel label { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 6px 0; }
    #panel input[type="range"] { width: 150px; }
    #panel .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    #panel .actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    #panel button, #panel select, #panel input[type="text"] { background: #1f2937; color:#e6edf3; border:1px solid #334155; border-radius:8px; padding:6px 10px; cursor:pointer; }
    #seedBox { width: 160px; }

    #helpBtn { position:fixed; top:12px; left:12px; z-index:8; background:#1f2937; border:1px solid #334155; color:#e6edf3; border-radius:8px; padding:8px 12px; cursor:pointer; }
    #helpDialog { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#111827; color:#e6edf3; width:min(640px,90vw); max-height:80vh; overflow:auto; padding:20px; border-radius:12px; box-shadow:0 0 20px rgba(0,0,0,.6); display:none; z-index:21; }
    #helpDialog h2 { margin-top:0; }
    #helpDialog button { margin-top:10px; background:#1f2937; color:#e6edf3; border:1px solid #334155; border-radius:6px; padding:6px 12px; cursor:pointer; }
    #helpDialog pre { background:#0f172a; padding:10px; border-radius:6px; overflow:auto; }
  </style>
  <script defer src="https://cdn.babylonjs.com/babylon.js"></script>
  <script defer src="world.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <button id="optsBtn" aria-haspopup="dialog">Options</button>
  <section id="panel" role="dialog" aria-modal="true" aria-label="Options">
    <h3>Controls</h3>
    <label>Invert look X <input id="optInvertX" type="checkbox"></label>
    <label>Invert look Y <input id="optInvertY" type="checkbox"></label>
    <label>Mouse sensitivity <input id="optSens" type="range" min="0.0005" max="0.02" step="0.0005" value="0.002"><span id="sensVal">0.002</span></label>
    <label>Walking speed (m/s) <input id="optSpeed" type="range" min="2" max="20" step="0.5" value="8"><span id="speedVal">8</span></label>
    <label>Right-click moves forward <input id="optRmb" type="checkbox" checked></label>

    <h3>Graphics</h3>
    <label>Quality
      <select id="optQuality">
        <option value="high">High</option>
        <option value="medium" selected>Medium</option>
        <option value="low">Low</option>
      </select>
    </label>
    <label>Show sky <input id="optSky" type="checkbox" checked></label>

    <h3>World</h3>
    <label>Tree count <input id="optTrees" type="range" min="0" max="200" step="5" value="30"><span id="treesVal">30</span></label>
    <div class="row"><label for="seedBox">Seed</label><input id="seedBox" type="text" inputmode="numeric" placeholder="auto" /><button id="btnApplySeed">Apply</button><button id="btnNewSeed">New</button></div>
    <div class="actions">
      <button id="btnRegenTrees">Regenerate trees</button>
      <button id="btnRegenGround">Regenerate terrain</button>
      <button id="btnFullscreen">Fullscreen</button>
    </div>
  </section>

  <button id="helpBtn">Help</button>
  <div id="helpDialog" role="dialog" aria-modal="true" aria-label="Help Manual">
    <h2>Vector World Help</h2>
    <p>Move with WASD/Arrows or left-half touch. Look with LMB drag or right-half touch. Hold RMB to walk forward.</p>
    <h3>Options</h3>
    <ul>
      <li>Controls: invert X/Y, sensitivity, walking speed, RMB forward toggle.</li>
      <li>Graphics: quality scaling, sky toggle.</li>
      <li>World: tree count, seed edit/new, regenerate trees and terrain, fullscreen.</li>
    </ul>
    <h3>Persistence</h3>
    <p>Settings and seed save to your browser and load on startup.</p>
    <h3>Notes</h3>
    <ul>
      <li>No pointer lock. Works in sandboxed iframes.</li>
      <li>Terrain features rivers, mesas, cliffs, and ruins seeded per world.</li>
      <li>Trees use instancing for performance and adapt to the terrain height.</li>
      <li>Movement is delta-time scaled.</li>
    </ul>
    <button id="closeHelp">Close</button>
  </div>

  <pre id="tests" aria-hidden="true"></pre>

  <script>
  const LS_SETTINGS_KEY = 'vw_settings_v1';
  const LS_WORLD_KEY    = 'vw_world_v1';
  const safeLoad = (k, d)=>{ try{ const v = JSON.parse(localStorage.getItem(k)); return (v && typeof v==='object')? v : d; }catch{ return d; } };
  const safeSave = (k, v)=>{ try{ localStorage.setItem(k, JSON.stringify(v)); }catch{} };

  window.addEventListener('DOMContentLoaded', () => {
    if (!window.WorldGen) { console.error('WorldGen module missing'); return; }
    const defaults = { invertX:false, invertY:false, sens:0.002, touchLookScale:12, moveSpeed:8.0, rmbForward:true, quality:'medium', sky:true, treeCount:30 };
    const settings = Object.assign({}, defaults, safeLoad(LS_SETTINGS_KEY, {}));
    const worldState = Object.assign({ seed: WorldGen.newSeed() }, safeLoad(LS_WORLD_KEY, {}));
    safeSave(LS_WORLD_KEY, worldState);

    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.53, 0.81, 0.92, 1.0);
    if (settings.quality==='high') engine.setHardwareScalingLevel(1);
    else if (settings.quality==='medium') engine.setHardwareScalingLevel(1.5);
    else engine.setHardwareScalingLevel(2);

    const cam = new BABYLON.UniversalCamera('cam', new BABYLON.Vector3(0, 6, -10), scene);
    cam.minZ = 0.1; cam.maxZ = 2000;
    cam.attachControl(canvas, true);
    cam.inputs.clear();
    scene.activeCamera = cam;

    new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0.2, 1, 0.2), scene);
    const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-1, -2, -1), scene);
    sun.intensity = 1.0;

    const worldConfig = { size: 240, sub: 160, height: 18, flat: 0.48 };
    const worldGen = WorldGen.createWorldGenerator(scene, worldConfig);
    let groundMesh = null;
    let waterMesh = null;

    function createGroundMaterial(sceneRef, world, { finalHeights }) {
      const mat = new BABYLON.StandardMaterial('groundMat', sceneRef);
      const texSize = 512;
      const tex = new BABYLON.DynamicTexture('groundTex', { width: texSize, height: texSize }, sceneRef, false);
      const ctx = tex.getContext();
      const width = world.sub + 1;
      const size = world.size;
      const step = size / world.sub;
      const ox = -size / 2;
      const oz = -size / 2;
      const sampleHeight = (wx, wz) => {
        const fx = (wx - ox) / step;
        const fz = (wz - oz) / step;
        const ix = Math.floor(fx);
        const iz = Math.floor(fz);
        if (ix < 0 || iz < 0 || ix >= world.sub || iz >= world.sub) return 0;
        const tx = fx - ix;
        const tz = fz - iz;
        const idx00 = iz * width + ix;
        const idx10 = idx00 + 1;
        const idx01 = idx00 + width;
        const idx11 = idx01 + 1;
        const h00 = finalHeights[idx00];
        const h10 = finalHeights[idx10];
        const h01 = finalHeights[idx01];
        const h11 = finalHeights[idx11];
        if (tx + tz < 1) {
          return h00 + (h10 - h00) * tx + (h01 - h00) * tz;
        }
        return h11 + (h10 - h11) * (1 - tz) + (h01 - h11) * (1 - tx);
      };
      const rng = WorldGen.mulberry32((worldState.seed >>> 0) ^ 0x51f15e5d);
      for (let y = 0; y < texSize; y++) {
        for (let x = 0; x < texSize; x++) {
          const u = x / (texSize - 1);
          const v = y / (texSize - 1);
          const wx = ox + u * size;
          const wz = oz + v * size;
          const h = sampleHeight(wx, wz);
          const norm = BABYLON.Scalar.Clamp(h / world.height, 0, 1);
          const fertile = Math.pow(1 - norm, 1.5);
          const dry = Math.pow(norm, 1.2);
          let r = BABYLON.Scalar.Lerp(78, 162, dry);
          let g = BABYLON.Scalar.Lerp(110, 190, fertile);
          let b = BABYLON.Scalar.Lerp(64, 132, fertile * 0.7 + dry * 0.2);
          const shade = (rng() - 0.5) * 16;
          r = BABYLON.Scalar.Clamp(r + shade, 0, 255);
          g = BABYLON.Scalar.Clamp(g + shade * 0.8, 0, 255);
          b = BABYLON.Scalar.Clamp(b + shade * 0.6, 0, 255);
          ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
          ctx.fillRect(x, y, 1, 1);
        }
      }
      tex.update();
      tex.wrapU = tex.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;
      tex.uScale = tex.vScale = 6;
      mat.diffuseTexture = tex;
      mat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
      mat.emissiveColor = new BABYLON.Color3(0.03, 0.06, 0.05);
      return mat;
    }

    function rebuildWorld(seedValue = worldState.seed, options = {}) {
      worldState.seed = seedValue >>> 0;
      const result = worldGen.build(worldState.seed, {
        groundMaterialFactory: (sceneRef, worldRef, info) => createGroundMaterial(sceneRef, worldRef, info)
      });
      groundMesh = result.ground;
      waterMesh = result.water;
      if (options.respawn) spawnCamera();
      else {
        const groundY = worldGen.groundHeightAt(cam.position.x, cam.position.z);
        if (cam.position.y < groundY) cam.position.y = groundY;
      }
      const seedInput = document.getElementById('seedBox');
      if (seedInput) seedInput.value = String(worldState.seed >>> 0);
      scatterTrees(settings.treeCount);
      safeSave(LS_WORLD_KEY, worldState);
    }

    const sky = BABYLON.MeshBuilder.CreateSphere('sky',{diameter:2000,sideOrientation:BABYLON.Mesh.BACKSIDE},scene);
    const skyTex=new BABYLON.DynamicTexture('skyTex',{width:1024,height:512},scene,false);
    const sctx=skyTex.getContext(); const grad=sctx.createLinearGradient(0,0,0,512); grad.addColorStop(0,'#9ed1f0'); grad.addColorStop(1,'#ffffff'); sctx.fillStyle=grad; sctx.fillRect(0,0,1024,512); skyTex.update();
    const skyMat=new BABYLON.StandardMaterial('skyMat',scene); skyMat.emissiveTexture=skyTex; skyMat.disableLighting=true; sky.material=skyMat;

    const trunkMat=new BABYLON.StandardMaterial('tm',scene); trunkMat.diffuseColor=new BABYLON.Color3(0.45,0.28,0.14); trunkMat.specularColor=new BABYLON.Color3(0.05,0.05,0.05);
    const leafMat=new BABYLON.StandardMaterial('lm',scene); leafMat.diffuseColor=new BABYLON.Color3(0.12,0.4,0.18); leafMat.emissiveColor=new BABYLON.Color3(0.02,0.08,0.03);
    const trunkBase = BABYLON.MeshBuilder.CreateCylinder('trunkBase',{diameterTop:0.6,diameterBottom:1.1,height:3.4},scene); trunkBase.material=trunkMat; trunkBase.setEnabled(false);
    const leavesBase = BABYLON.MeshBuilder.CreateSphere('leavesBase',{diameter:4.6},scene); leavesBase.material=leafMat; leavesBase.setEnabled(false);

    const treeInstances = [];
    function clearTrees(){
      while (treeInstances.length) {
        const mesh = treeInstances.pop();
        try { mesh.dispose(); } catch (err) { console.warn('tree dispose', err); }
      }
    }

    function createTreeInstance(x, groundY, z, scale, yaw){
      const trunk = trunkBase.createInstance(`trunk${treeInstances.length}`);
      trunk.scaling = new BABYLON.Vector3(1, scale, 1);
      trunk.position.set(x, groundY + 1.7 * scale, z);
      trunk.rotation.y = yaw;
      const leaves = leavesBase.createInstance(`leaves${treeInstances.length}`);
      leaves.scaling.set(scale * 1.1, scale * 1.05, scale * 1.1);
      leaves.position.set(x, groundY + 3.2 * scale + 1.8 * scale, z);
      leaves.rotation.y = yaw;
      treeInstances.push(leaves, trunk);
    }

    function scatterTrees(count){
      clearTrees();
      if (!groundMesh) return;
      const rng = WorldGen.mulberry32((worldState.seed >>> 0) ^ 0x85ebca6b);
      const radius = worldGen.world.size * 0.45;
      let attempts = 0;
      while (treeInstances.length / 2 < count && attempts < count * 4) {
        const angle = rng() * Math.PI * 2;
        const dist = Math.sqrt(rng()) * radius;
        const x = Math.cos(angle) * dist;
        const z = Math.sin(angle) * dist;
        const groundY = worldGen.groundHeightAt(x, z) - 1.6;
        if (!isFinite(groundY)) { attempts++; continue; }
        const scale = 0.75 + rng() * 0.85;
        const yaw = rng() * Math.PI * 2;
        createTreeInstance(x, groundY, z, scale, yaw);
        attempts++;
      }
      safeSave(LS_WORLD_KEY, worldState);
    }

    function spawnCamera(){
      const spawn = worldGen.pickSpawn();
      if (spawn) {
        cam.position.copyFrom(spawn);
        cam.rotation.x = 0;
        cam.rotation.y = 0;
      }
    }

    rebuildWorld(worldState.seed, { respawn: true });

    const inputMap = {};
    scene.actionManager = new BABYLON.ActionManager(scene);
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, (evt)=>{ inputMap[evt.sourceEvent.code] = true; }));
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger,   (evt)=>{ inputMap[evt.sourceEvent.code] = false; }));
    window.addEventListener('keydown', (e)=>{ if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault(); }, {passive:false});

    let lmb=false, rmb=false, dragging=false, lastX=0, lastY=0;
    const rotateByDelta=(dx,dy)=>{ const sx = (settings.invertX?-1:1) * settings.sens; const sy = (settings.invertY?-1:1) * settings.sens; cam.rotation.y += dx * sx; cam.rotation.x = BABYLON.Scalar.Clamp(cam.rotation.x + dy * sy, -Math.PI/2, Math.PI/2); };
    const syncButtons = (buttons)=>{ lmb = (buttons & 1) === 1; rmb = settings.rmbForward && ((buttons & 2) === 2); dragging = lmb; canvas.style.cursor = dragging ? 'none' : 'crosshair'; };

    canvas.addEventListener('pointerdown', (e)=>{ if (e.pointerType === 'mouse') { syncButtons(e.buttons | (1<<e.button)); lastX=e.clientX; lastY=e.clientY; e.preventDefault(); }}, {passive:false});
    document.addEventListener('pointerup', (e)=>{ if (e.pointerType === 'mouse') syncButtons(e.buttons & ~(1<<e.button)); }, {capture:true});
    canvas.addEventListener('pointermove', (e)=>{ if (e.pointerType === 'mouse') { syncButtons(e.buttons); if (dragging) { const dx = (typeof e.movementX==='number')? e.movementX : (e.clientX-lastX); const dy = (typeof e.movementY==='number')? e.movementY : (e.clientY-lastY); lastX=e.clientX; lastY=e.clientY; rotateByDelta(dx,dy); } } });
    window.addEventListener('blur', ()=>{ lmb=false; rmb=false; dragging=false; canvas.style.cursor='crosshair'; });
    document.addEventListener('contextmenu', (e)=> e.preventDefault(), {capture:true});

    let moveTouchId=null, lookTouchId=null; let moveVecX=0, moveVecY=0; const stickRadius = 80; const origin = {mx:0,my:0,lx:0,ly:0};
    const touchVec = (ox,oy,x,y)=>{ const dx=x-ox, dy=y-oy; const len=Math.hypot(dx,dy)||1; const cl=Math.min(len, stickRadius); return { x:(dx/len)*cl/stickRadius, y:(dy/len)*cl/stickRadius }; };
    canvas.addEventListener('touchstart', (e)=>{ for (const t of e.changedTouches) { if (t.clientX < window.innerWidth*0.5 && moveTouchId===null) { moveTouchId=t.identifier; origin.mx=t.clientX; origin.my=t.clientY; moveVecX=0; moveVecY=0; } else if (lookTouchId===null) { lookTouchId=t.identifier; origin.lx=t.clientX; origin.ly=t.clientY; } } }, {passive:false});
    canvas.addEventListener('touchmove', (e)=>{ for (const t of e.changedTouches) { if (t.identifier===moveTouchId) { const v = touchVec(origin.mx, origin.my, t.clientX, t.clientY); moveVecX = v.x; moveVecY = -v.y; } else if (t.identifier===lookTouchId) { const v = touchVec(origin.lx, origin.ly, t.clientX, t.clientY); rotateByDelta(v.x * settings.touchLookScale, v.y * settings.touchLookScale); } } e.preventDefault(); }, {passive:false});
    const endTouch=(e)=>{ for (const t of e.changedTouches) { if (t.identifier===moveTouchId) { moveTouchId=null; moveVecX=0; moveVecY=0; } if (t.identifier===lookTouchId) { lookTouchId=null; } } };
    canvas.addEventListener('touchend', endTouch); canvas.addEventListener('touchcancel', endTouch);

    scene.onBeforeRenderObservable.add(()=>{
      const dt = Math.min(engine.getDeltaTime()*0.001, 0.05);
      worldGen.update(dt);
      const move = settings.moveSpeed * dt;
      const sinY=Math.sin(cam.rotation.y), cosY=Math.cos(cam.rotation.y);
      const forward = new BABYLON.Vector3(sinY,0,cosY); const right = new BABYLON.Vector3(cosY,0,-sinY);
      let dx = 0, dz = 0;
      if (inputMap['KeyA'] || inputMap['ArrowLeft'])  dx -= 1;
      if (inputMap['KeyD'] || inputMap['ArrowRight']) dx += 1;
      if (inputMap['KeyW'] || inputMap['ArrowUp'] || rmb) dz += 1;
      if (inputMap['KeyS'] || inputMap['ArrowDown'])   dz -= 1;
      dx += moveVecX; dz += moveVecY;
      if (dx!==0 || dz!==0) { const len = Math.hypot(dx,dz); dx/=len; dz/=len; cam.position.addInPlace(right.scale(dx*move)).addInPlace(forward.scale(dz*move)); }
      const groundY = worldGen.groundHeightAt(cam.position.x, cam.position.z);
      if (cam.position.y < groundY) cam.position.y = groundY;
      sky.setEnabled(settings.sky);
    });

    engine.runRenderLoop(()=> scene.render());
    window.addEventListener('resize',()=> engine.resize());

    const $ = (id)=>document.getElementById(id);
    const panel = $('panel'); const btn = $('optsBtn');
    const bind = ()=>{ $('optInvertX').checked = settings.invertX; $('optInvertY').checked = settings.invertY; $('optSens').value = settings.sens; $('sensVal').textContent = settings.sens.toFixed(3); $('optSpeed').value = settings.moveSpeed; $('speedVal').textContent = settings.moveSpeed.toFixed(1); $('optRmb').checked = settings.rmbForward; $('optQuality').value = settings.quality; $('optSky').checked = settings.sky; $('optTrees').value = settings.treeCount; $('treesVal').textContent = settings.treeCount; $('seedBox').value = String(worldState.seed); };
    bind();
    const persist = ()=> safeSave(LS_SETTINGS_KEY, settings);
    btn.addEventListener('click', ()=>{ panel.style.display = (panel.style.display==='none'||!panel.style.display)?'block':'none'; });
    $('optInvertX').addEventListener('change', e=> { settings.invertX = e.target.checked; persist(); });
    $('optInvertY').addEventListener('change', e=> { settings.invertY = e.target.checked; persist(); });
    $('optSens').addEventListener('input', e=> { settings.sens = parseFloat(e.target.value); $('sensVal').textContent = settings.sens.toFixed(3); persist(); });
    $('optSpeed').addEventListener('input', e=> { settings.moveSpeed = parseFloat(e.target.value); $('speedVal').textContent = settings.moveSpeed.toFixed(1); persist(); });
    $('optRmb').addEventListener('change', e=> { settings.rmbForward = e.target.checked; if (!settings.rmbForward) rmb=false; persist(); });
    $('optQuality').addEventListener('change', e=> { settings.quality = e.target.value; persist(); if (settings.quality==='high') engine.setHardwareScalingLevel(1); else if (settings.quality==='medium') engine.setHardwareScalingLevel(1.5); else engine.setHardwareScalingLevel(2); });
    $('optSky').addEventListener('change', e=> { settings.sky = e.target.checked; persist(); });
    $('optTrees').addEventListener('input', e=> { settings.treeCount = parseInt(e.target.value,10); $('treesVal').textContent = settings.treeCount; persist(); scatterTrees(settings.treeCount); });
    $('btnRegenTrees').addEventListener('click', ()=> { scatterTrees(settings.treeCount); });
    $('btnRegenGround').addEventListener('click', ()=> { rebuildWorld(worldState.seed, { respawn: false }); });
    $('btnFullscreen').addEventListener('click', async ()=> { try { await (document.documentElement.requestFullscreen?.() || Promise.reject()); } catch {} });
    $('btnApplySeed').addEventListener('click', ()=>{ const n = Number($('seedBox').value); if (Number.isFinite(n) && n>=0 && n<=0xFFFFFFFF) { rebuildWorld(n>>>0, { respawn: true }); } });
    $('btnNewSeed').addEventListener('click', ()=>{ const seed = WorldGen.newSeed(); $('seedBox').value = String(seed); rebuildWorld(seed, { respawn: true }); });

    const helpBtn=document.getElementById('helpBtn'); const helpDialog=document.getElementById('helpDialog'); const closeHelp=document.getElementById('closeHelp');
    helpBtn.addEventListener('click',()=>{ helpDialog.style.display='block'; });
    closeHelp.addEventListener('click',()=>{ helpDialog.style.display='none'; });
    window.addEventListener('keydown', e=>{ if(e.key==='Escape') helpDialog.style.display='none'; });

    const testsEl = document.getElementById('tests');
    const tests=[]; const test=(name,fn)=>{ try{ if(fn()===false) throw new Error('assert'); tests.push(['PASS',name]); }catch(e){ tests.push(['FAIL',name,e?.message||String(e)]);} };
    test('Engine live', ()=> typeof BABYLON!=='undefined' && engine && scene && canvas);
    test('UI present', ()=> document.getElementById('optsBtn') && document.getElementById('helpBtn'));
    test('Persistence wired', ()=> localStorage !== undefined);
    test('Terrain mesh ready', ()=> groundMesh && groundMesh.getTotalVertices() > 0);
    test('Water mesh ready', ()=> waterMesh && waterMesh.getTotalVertices() > 0);
    test('Height sampling finite', ()=> Number.isFinite(worldGen.groundHeightAt(0,0)));
    testsEl.textContent = tests.map(t=>`${t[0]} — ${t[1]}${t[2]?': '+t[2]:''}`).join('\n');
    console.table(tests);
  });
  </script>
</body>
</html>
