<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Vector World â€” Babylon</title>
  <style>
    html, body { height: 100%; margin: 0; background: #87ceeb; touch-action: none; }
    #renderCanvas { width: 100%; height: 100%; display: block; cursor: crosshair; }
    #tests { position:fixed; left:10px; bottom:10px; z-index:7; background:rgba(0,0,0,.65); color:#e6edf3; padding:6px 8px; border-radius:8px; font:12px system-ui; white-space:pre; max-width:60vw; max-height:30vh; overflow:auto; }

    #optsBtn { position: fixed; right: 12px; top: 12px; z-index: 8; border: 0; padding: 10px 12px; border-radius: 10px; background: rgba(0,0,0,.65); color: #fff; font: 14px/1 system-ui; cursor: pointer; }
    #panel { position: fixed; right: 12px; top: 52px; z-index: 9; width: min(380px, 92vw); max-height: 80vh; overflow: auto; padding: 14px; border-radius: 12px; backdrop-filter: blur(6px); background: rgba(10,12,20,.85); color:#e6edf3; font: 13px system-ui; display: none; }
    #panel h3 { margin: 6px 0 8px; font-size: 14px; color: #bcd; }
    #panel label { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 6px 0; }
    #panel input[type="range"] { width: 150px; }
    #panel .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    #panel .actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    #panel button, #panel select, #panel input[type="text"] { background: #1f2937; color:#e6edf3; border:1px solid #334155; border-radius:8px; padding:6px 10px; cursor:pointer; }
    #seedBox { width: 160px; }

    #helpBtn { position:fixed; top:12px; left:12px; z-index:8; background:#1f2937; border:1px solid #334155; color:#e6edf3; border-radius:8px; padding:8px 12px; cursor:pointer; }
    #helpDialog { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#111827; color:#e6edf3; width:min(640px,90vw); max-height:80vh; overflow:auto; padding:20px; border-radius:12px; box-shadow:0 0 20px rgba(0,0,0,.6); display:none; z-index:21; }
    #helpDialog h2 { margin-top:0; }
    #helpDialog button { margin-top:10px; background:#1f2937; color:#e6edf3; border:1px solid #334155; border-radius:6px; padding:6px 12px; cursor:pointer; }
    #helpDialog pre { background:#0f172a; padding:10px; border-radius:6px; overflow:auto; }
  </style>
  <script defer src="https://cdn.babylonjs.com/babylon.js"></script>
  <script defer src="world.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <button id="optsBtn" aria-haspopup="dialog">Options</button>
  <section id="panel" role="dialog" aria-modal="true" aria-label="Options">
    <h3>Controls</h3>
    <label>Invert look X <input id="optInvertX" type="checkbox"></label>
    <label>Invert look Y <input id="optInvertY" type="checkbox"></label>
    <label>Mouse sensitivity <input id="optSens" type="range" min="0.0005" max="0.02" step="0.0005" value="0.002"><span id="sensVal">0.002</span></label>
    <label>Walking speed (m/s) <input id="optSpeed" type="range" min="2" max="20" step="0.5" value="8"><span id="speedVal">8</span></label>
    <label>Right-click moves forward <input id="optRmb" type="checkbox" checked></label>

    <h3>Graphics</h3>
    <label>Quality
      <select id="optQuality">
        <option value="high">High</option>
        <option value="medium" selected>Medium</option>
        <option value="low">Low</option>
      </select>
    </label>
    <label>Show sky <input id="optSky" type="checkbox" checked></label>

    <h3>World</h3>
    <label>Tree count <input id="optTrees" type="range" min="0" max="200" step="5" value="30"><span id="treesVal">30</span></label>
    <div class="row"><label for="seedBox">Seed</label><input id="seedBox" type="text" inputmode="numeric" placeholder="auto" /><button id="btnApplySeed">Apply</button><button id="btnNewSeed">New</button></div>
    <div class="actions">
      <button id="btnRegenTrees">Regenerate trees</button>
      <button id="btnRegenGround">Regenerate terrain</button>
      <button id="btnFullscreen">Fullscreen</button>
    </div>
  </section>

  <button id="helpBtn">Help</button>
  <div id="helpDialog" role="dialog" aria-modal="true" aria-label="Help Manual">
    <h2>Vector World Help</h2>
    <p>Move with WASD/Arrows or left-half touch. Look with LMB drag or right-half touch. Hold RMB to walk forward.</p>
    <h3>Options</h3>
    <ul>
      <li>Controls: invert X/Y, sensitivity, walking speed, RMB forward toggle.</li>
      <li>Graphics: quality scaling, sky toggle.</li>
      <li>World: tree count, seed edit/new, regenerate trees and terrain, fullscreen.</li>
    </ul>
    <h3>Persistence</h3>
    <p>Settings and seed save to your browser and load on startup.</p>
    <h3>Notes</h3>
    <ul>
      <li>No pointer lock. Works in sandboxed iframes.</li>
      <li>Terrain features rivers, mesas, cliffs, and ruins seeded per world.</li>
      <li>Trees use instancing for performance and adapt to the terrain height.</li>
      <li>Movement is delta-time scaled.</li>
    </ul>
    <button id="closeHelp">Close</button>
  </div>

  <pre id="tests" aria-hidden="true"></pre>

  <script>
  const LS_SETTINGS_KEY = 'vw_settings_v1';
  const LS_WORLD_KEY    = 'vw_world_v1';
  const safeLoad = (k, d)=>{ try{ const v = JSON.parse(localStorage.getItem(k)); return (v && typeof v==='object')? v : d; }catch{ return d; } };
  const safeSave = (k, v)=>{ try{ localStorage.setItem(k, JSON.stringify(v)); }catch{} };

  window.addEventListener('DOMContentLoaded', () => {
    if (!window.WorldGen) { console.error('WorldGen module missing'); return; }
    const defaults = { invertX:false, invertY:false, sens:0.002, touchLookScale:12, moveSpeed:8.0, rmbForward:true, quality:'medium', sky:true, treeCount:30 };
    const settings = Object.assign({}, defaults, safeLoad(LS_SETTINGS_KEY, {}));
    const worldState = Object.assign({ seed: WorldGen.newSeed() }, safeLoad(LS_WORLD_KEY, {}));
    safeSave(LS_WORLD_KEY, worldState);

    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.53, 0.81, 0.92, 1.0);
    if (settings.quality==='high') engine.setHardwareScalingLevel(1);
    else if (settings.quality==='medium') engine.setHardwareScalingLevel(1.5);
    else engine.setHardwareScalingLevel(2);

    const cam = new BABYLON.UniversalCamera('cam', new BABYLON.Vector3(0, 6, -10), scene);
    cam.minZ = 0.1; cam.maxZ = 2000; cam.speed = 0.8; cam.inertia = 0; cam.angularSensibility = 2000;
    cam.attachControl(canvas, true);
    cam.applyGravity = false; cam.checkCollisions = false;
    cam.inputs.clear();
    scene.activeCamera = cam;

    new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0.2, 1, 0.2), scene);
    const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-1, -2, -1), scene);
    sun.intensity = 1.0;

    const worldConfig = { size: 240, subdivisions: 160, height: 18, flatten: 0.6, radius: 2 };

    class Perlin {
      constructor(seed=1){
        this.p=new Uint8Array(512);
        const perm=new Uint8Array(256);
        for(let i=0;i<256;i++) perm[i]=i;
        let s=seed>>>0;
        for(let i=255;i>0;i--){
          s=(s*1664525+1013904223)>>>0;
          const j=s%(i+1);
          const t=perm[i];
          perm[i]=perm[j];
          perm[j]=t;
        }
        for(let i=0;i<512;i++) this.p[i]=perm[i&255];
      }
      fade(t){ return t*t*t*(t*(t*6-15)+10); }
      lerp(t,a,b){ return a+t*(b-a); }
      grad(h,x,y,z){ const H=h&15; const u=H<8?x:y; const v=H<4?y:H===12||H===14?x:z; return ((H&1)===0?u:-u)+((H&2)===0?v:-v); }
      noise(x,y=0,z=0){
        const X=Math.floor(x)&255, Y=Math.floor(y)&255, Z=Math.floor(z)&255;
        x-=Math.floor(x); y-=Math.floor(y); z-=Math.floor(z);
        const u=this.fade(x), v=this.fade(y), w=this.fade(z), p=this.p;
        const A=p[X]+Y, AA=p[A]+Z, AB=p[A+1]+Z;
        const B=p[X+1]+Y, BA=p[B]+Z, BB=p[B+1]+Z;
        return this.lerp(w,
          this.lerp(v,
            this.lerp(u, this.grad(p[AA],x,y,z), this.grad(p[BA],x-1,y,z)),
            this.lerp(u, this.grad(p[AB],x,y-1,z), this.grad(p[BB],x-1,y-1,z))
          ),
          this.lerp(v,
            this.lerp(u, this.grad(p[AA+1],x,y,z-1), this.grad(p[BA+1],x-1,y,z-1)),
            this.lerp(u, this.grad(p[AB+1],x,y-1,z-1), this.grad(p[BB+1],x-1,y-1,z-1))
          )
        );
      }
    }

    const createHeightSampler = (config, seed)=>{
      const perlin = new Perlin(seed);
      const baseFreq = 0.012;
      return (x,z)=>{
        const n1 = perlin.noise(x*baseFreq, 0, z*baseFreq);
        const n2 = perlin.noise(x*baseFreq*2, 0, z*baseFreq*2) * 0.5;
        const n3 = perlin.noise(x*baseFreq*4, 0, z*baseFreq*4) * 0.25;
        let h = ((n1 + n2 + n3) * 0.5 + 0.5);
        h = BABYLON.Scalar.Lerp(h, 0.5, config.flatten);
        return h * config.height;
      };
    };

    const createTerrainTileBuilder = (scene, config, samplerRef, material)=>{
      const { size, subdivisions } = config;
      let templatePositions = null;
      return (mesh, centerX, centerZ)=>{
        let groundMesh = mesh;
        if(!groundMesh){
          groundMesh = BABYLON.MeshBuilder.CreateGround('chunk', { width:size, height:size, subdivisions, updatable:true }, scene);
          groundMesh.material = material;
          groundMesh.isPickable = false;
        }
        const positions = groundMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        if(!templatePositions) templatePositions = positions.slice();
        const sampler = samplerRef();
        for(let i=0;i<positions.length;i+=3){
          const lx = templatePositions[i];
          const lz = templatePositions[i+2];
          positions[i] = lx;
          positions[i+2] = lz;
          positions[i+1] = sampler(lx + centerX, lz + centerZ);
        }
        groundMesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
        const normals = groundMesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);
        BABYLON.VertexData.ComputeNormals(positions, groundMesh.getIndices(), normals);
        groundMesh.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);
        groundMesh.position.set(centerX, 0, centerZ);
        groundMesh.refreshBoundingInfo();
        return groundMesh;
      };
    };

    class WorldStreamer {
      constructor(scene, camera, options){
        this.scene = scene;
        this.camera = camera;
        this.size = options.size;
        this.radius = options.radius ?? 2;
        this.buildTile = options.buildTile;
        this.pool = [];
        this.active = new Map();
        this.center = null;
        this.tileId = 0;

        this.scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
        this.scene.fogColor = new BABYLON.Color3(
          this.scene.clearColor.r,
          this.scene.clearColor.g,
          this.scene.clearColor.b
        );
        this._applyViewSettings();
      }

      _applyViewSettings(){
        const span = this.size * (this.radius * 2 + 1);
        this.camera.maxZ = span * 1.4;
        this.scene.fogStart = span * 0.6;
        this.scene.fogEnd = span * 1.1;
      }

      _chunkKey(ix, iz){ return `${ix},${iz}`; }

      _chunkCoords(x, z){
        const size = this.size;
        const ix = Math.floor((x + size * 0.5) / size);
        const iz = Math.floor((z + size * 0.5) / size);
        return { ix, iz };
      }

      _acquireTile(ix, iz){
        const centerX = ix * this.size;
        const centerZ = iz * this.size;
        let mesh = this.pool.pop() ?? null;
        mesh = this.buildTile(mesh, centerX, centerZ);
        mesh.name = `chunk_${ix}_${iz}_${this.tileId++}`;
        mesh.setEnabled(true);
        return { mesh, ix, iz };
      }

      _releaseTile(entry){
        entry.mesh.setEnabled(false);
        this.pool.push(entry.mesh);
      }

      update(force=false){
        this._applyViewSettings();
        const { ix, iz } = this._chunkCoords(this.camera.position.x, this.camera.position.z);
        const changed = !this.center || this.center.ix !== ix || this.center.iz !== iz;
        if (!changed && !force) return;
        this.center = { ix, iz };

        const needed = [];
        const neededKeys = new Set();
        for(let dz=-this.radius; dz<=this.radius; dz++){
          for(let dx=-this.radius; dx<=this.radius; dx++){
            const cx = ix + dx;
            const cz = iz + dz;
            const key = this._chunkKey(cx, cz);
            needed.push({ key, ix: cx, iz: cz });
            neededKeys.add(key);
          }
        }

        for (const [key, entry] of Array.from(this.active.entries())){
          if (!neededKeys.has(key)){
            this.active.delete(key);
            this._releaseTile(entry);
          }
        }

        for (const chunk of needed){
          if (!this.active.has(chunk.key)){
            const entry = this._acquireTile(chunk.ix, chunk.iz);
            this.active.set(chunk.key, entry);
          }
        }
      }

      rebuildActive(){
        for (const entry of this.active.values()){
          const centerX = entry.ix * this.size;
          const centerZ = entry.iz * this.size;
          entry.mesh = this.buildTile(entry.mesh, centerX, centerZ);
        }
      }

      activeCount(){ return this.active.size; }
    }

    function makeGroundTexture(size=512){
      const rnd = mulberry32(worldState.seed ^ 0x9e3779b9);
      const tex=new BABYLON.DynamicTexture('ground',{width:size,height:size},scene,false);
      const ctx=tex.getContext();
      for(let y=0;y<size;y++){
        for(let x=0;x<size;x++){
          const g=100+Math.floor(rnd()*80);
          const r=50+Math.floor(rnd()*30);
          const b=50+Math.floor(rnd()*30);
          ctx.fillStyle=`rgb(${r},${g},${b})`;
          ctx.fillRect(x,y,1,1);
        }
      }
      tex.update(); tex.wrapU=tex.wrapV=BABYLON.Texture.WRAP_ADDRESSMODE; tex.uScale=8; tex.vScale=8; return tex;
    }

    const groundMaterial = new BABYLON.StandardMaterial('groundMat', scene);
    groundMaterial.diffuseTexture = makeGroundTexture();
    groundMaterial.specularColor = new BABYLON.Color3(0,0,0);

    const sky = BABYLON.MeshBuilder.CreateSphere('sky',{diameter:2000,sideOrientation:BABYLON.Mesh.BACKSIDE},scene);
    const skyTex=new BABYLON.DynamicTexture('skyTex',{width:1024,height:512},scene,false);
    const sctx=skyTex.getContext(); const grad=sctx.createLinearGradient(0,0,0,512); grad.addColorStop(0,'#9ed1f0'); grad.addColorStop(1,'#ffffff'); sctx.fillStyle=grad; sctx.fillRect(0,0,1024,512); skyTex.update();
    const skyMat=new BABYLON.StandardMaterial('skyMat',scene); skyMat.emissiveTexture=skyTex; skyMat.disableLighting=true; sky.material=skyMat;

    const trunkMat=new BABYLON.StandardMaterial('tm',scene); trunkMat.diffuseColor=new BABYLON.Color3(0.55,0.27,0.07);
    const leafMat =new BABYLON.StandardMaterial('lm',scene); leafMat.diffuseColor =new BABYLON.Color3(0,0.5,0);
    const trunkBase = BABYLON.MeshBuilder.CreateCylinder('trunkBase',{diameterTop:0.8,diameterBottom:1,height:3},scene); trunkBase.material = trunkMat; trunkBase.setEnabled(false);
    const leavesBase = BABYLON.MeshBuilder.CreateSphere('leavesBase',{diameter:4},scene); leavesBase.material = leafMat; leavesBase.setEnabled(false);

    let heightSampler = createHeightSampler(worldConfig, worldState.seed);
    const terrainHeightAt = (x,z)=> heightSampler ? heightSampler(x,z) : 0;
    const groundHeightAt = (x,z)=> terrainHeightAt(x,z) + 1.6;
    const buildTerrainTile = createTerrainTileBuilder(scene, worldConfig, ()=>heightSampler, groundMaterial);
    const worldStreamer = new WorldStreamer(scene, cam, { size: worldConfig.size, radius: worldConfig.radius, buildTile: buildTerrainTile });

    function positionCamera(){
      for(let n=0;n<200;n++){
        const x=(Math.random()-0.5)*worldConfig.size*0.5;
        const z=(Math.random()-0.5)*worldConfig.size*0.5;
        const y=groundHeightAt(x,z);
        if(Number.isFinite(y)){ cam.position.set(x,y,z); return; }
      }
      cam.position.set(0, groundHeightAt(0,0), 0);
    }

    positionCamera();
    worldStreamer.update(true);

    let treeInstances = [];
    function clearTrees(){ treeInstances.forEach(m=>m.dispose()); treeInstances.length=0; }
    function createTree(x,z){
      const terrainY = terrainHeightAt(x,z);
      const t = trunkBase.createInstance('trunk');
      const l = leavesBase.createInstance('leaves');
      t.position.set(x, terrainY + 1.5, z);
      l.position.set(x, terrainY + 5, z);
      treeInstances.push(t,l);
      return [t,l];
    }
    function scatterTrees(count){
      clearTrees();
      const rnd = mulberry32(worldState.seed ^ 0x85ebca6b);
      for(let i=0;i<count;i++){
        const x=(rnd()-0.5)*worldConfig.size*0.75;
        const z=(rnd()-0.5)*worldConfig.size*0.75;
        createTree(x,z);
      }
      safeSave(LS_WORLD_KEY, worldState);
    }
    scatterTrees(settings.treeCount);

    const inputMap = {};
    scene.actionManager = new BABYLON.ActionManager(scene);
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, (evt)=>{ inputMap[evt.sourceEvent.code] = true; }));
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger,   (evt)=>{ inputMap[evt.sourceEvent.code] = false; }));
    window.addEventListener('keydown', (e)=>{ if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault(); }, {passive:false});

    let lmb=false, rmb=false, dragging=false, lastX=0, lastY=0;
    const rotateByDelta=(dx,dy)=>{ const sx = (settings.invertX?-1:1) * settings.sens; const sy = (settings.invertY?-1:1) * settings.sens; cam.rotation.y += dx * sx; cam.rotation.x = BABYLON.Scalar.Clamp(cam.rotation.x + dy * sy, -Math.PI/2, Math.PI/2); };
    const syncButtons = (buttons)=>{ lmb = (buttons & 1) === 1; rmb = settings.rmbForward && ((buttons & 2) === 2); dragging = lmb; canvas.style.cursor = dragging ? 'none' : 'crosshair'; };

    canvas.addEventListener('pointerdown', (e)=>{ if (e.pointerType === 'mouse') { syncButtons(e.buttons | (1<<e.button)); lastX=e.clientX; lastY=e.clientY; e.preventDefault(); }}, {passive:false});
    document.addEventListener('pointerup', (e)=>{ if (e.pointerType === 'mouse') syncButtons(e.buttons & ~(1<<e.button)); }, {capture:true});
    canvas.addEventListener('pointermove', (e)=>{ if (e.pointerType === 'mouse') { syncButtons(e.buttons); if (dragging) { const dx = (typeof e.movementX==='number')? e.movementX : (e.clientX-lastX); const dy = (typeof e.movementY==='number')? e.movementY : (e.clientY-lastY); lastX=e.clientX; lastY=e.clientY; rotateByDelta(dx,dy); } } });
    window.addEventListener('blur', ()=>{ lmb=false; rmb=false; dragging=false; canvas.style.cursor='crosshair'; });
    document.addEventListener('contextmenu', (e)=> e.preventDefault(), {capture:true});

    let moveTouchId=null, lookTouchId=null; let moveVecX=0, moveVecY=0; const stickRadius = 80; const origin = {mx:0,my:0,lx:0,ly:0};
    const touchVec = (ox,oy,x,y)=>{ const dx=x-ox, dy=y-oy; const len=Math.hypot(dx,dy)||1; const cl=Math.min(len, stickRadius); return { x:(dx/len)*cl/stickRadius, y:(dy/len)*cl/stickRadius }; };
    canvas.addEventListener('touchstart', (e)=>{ for (const t of e.changedTouches) { if (t.clientX < window.innerWidth*0.5 && moveTouchId===null) { moveTouchId=t.identifier; origin.mx=t.clientX; origin.my=t.clientY; moveVecX=0; moveVecY=0; } else if (lookTouchId===null) { lookTouchId=t.identifier; origin.lx=t.clientX; origin.ly=t.clientY; } } }, {passive:false});
    canvas.addEventListener('touchmove', (e)=>{ for (const t of e.changedTouches) { if (t.identifier===moveTouchId) { const v = touchVec(origin.mx, origin.my, t.clientX, t.clientY); moveVecX = v.x; moveVecY = -v.y; } else if (t.identifier===lookTouchId) { const v = touchVec(origin.lx, origin.ly, t.clientX, t.clientY); rotateByDelta(v.x * settings.touchLookScale, v.y * settings.touchLookScale); } } e.preventDefault(); }, {passive:false});
    const endTouch=(e)=>{ for (const t of e.changedTouches) { if (t.identifier===moveTouchId) { moveTouchId=null; moveVecX=0; moveVecY=0; } if (t.identifier===lookTouchId) { lookTouchId=null; } } };
    canvas.addEventListener('touchend', endTouch); canvas.addEventListener('touchcancel', endTouch);

    scene.onBeforeRenderObservable.add(()=>{
      const dt = Math.min(engine.getDeltaTime()*0.001, 0.05);
      worldGen.update(dt);
      const move = settings.moveSpeed * dt;
      const sinY=Math.sin(cam.rotation.y), cosY=Math.cos(cam.rotation.y);
      const forward = new BABYLON.Vector3(sinY,0,cosY); const right = new BABYLON.Vector3(cosY,0,-sinY);
      let dx = 0, dz = 0;
      if (inputMap['KeyA'] || inputMap['ArrowLeft'])  dx -= 1;
      if (inputMap['KeyD'] || inputMap['ArrowRight']) dx += 1;
      if (inputMap['KeyW'] || inputMap['ArrowUp'] || rmb) dz += 1;
      if (inputMap['KeyS'] || inputMap['ArrowDown'])   dz -= 1;
      dx += moveVecX; dz += moveVecY;
      if (dx!==0 || dz!==0) { const len = Math.hypot(dx,dz); dx/=len; dz/=len; cam.position.addInPlace(right.scale(dx*move)).addInPlace(forward.scale(dz*move)); }
      worldStreamer.update();
      const targetY = groundHeightAt(cam.position.x, cam.position.z);
      cam.position.y = BABYLON.Scalar.Lerp(cam.position.y, targetY, 0.4);
      sky.setEnabled(settings.sky);
    });

    engine.runRenderLoop(()=> scene.render());
    window.addEventListener('resize',()=> engine.resize());

    const $ = (id)=>document.getElementById(id);
    const panel = $('panel'); const btn = $('optsBtn');
    const bind = ()=>{ $('optInvertX').checked = settings.invertX; $('optInvertY').checked = settings.invertY; $('optSens').value = settings.sens; $('sensVal').textContent = settings.sens.toFixed(3); $('optSpeed').value = settings.moveSpeed; $('speedVal').textContent = settings.moveSpeed.toFixed(1); $('optRmb').checked = settings.rmbForward; $('optQuality').value = settings.quality; $('optSky').checked = settings.sky; $('optTrees').value = settings.treeCount; $('treesVal').textContent = settings.treeCount; $('seedBox').value = String(worldState.seed); };
    bind();
    const persist = ()=> safeSave(LS_SETTINGS_KEY, settings);
    btn.addEventListener('click', ()=>{ panel.style.display = (panel.style.display==='none'||!panel.style.display)?'block':'none'; });
    $('optInvertX').addEventListener('change', e=> { settings.invertX = e.target.checked; persist(); });
    $('optInvertY').addEventListener('change', e=> { settings.invertY = e.target.checked; persist(); });
    $('optSens').addEventListener('input', e=> { settings.sens = parseFloat(e.target.value); $('sensVal').textContent = settings.sens.toFixed(3); persist(); });
    $('optSpeed').addEventListener('input', e=> { settings.moveSpeed = parseFloat(e.target.value); $('speedVal').textContent = settings.moveSpeed.toFixed(1); persist(); });
    $('optRmb').addEventListener('change', e=> { settings.rmbForward = e.target.checked; if (!settings.rmbForward) rmb=false; persist(); });
    $('optQuality').addEventListener('change', e=> { settings.quality = e.target.value; persist(); if (settings.quality==='high') engine.setHardwareScalingLevel(1); else if (settings.quality==='medium') engine.setHardwareScalingLevel(1.5); else engine.setHardwareScalingLevel(2); });
    $('optSky').addEventListener('change', e=> { settings.sky = e.target.checked; persist(); });
    $('optTrees').addEventListener('input', e=> { settings.treeCount = parseInt(e.target.value,10); $('treesVal').textContent = settings.treeCount; persist(); scatterTrees(settings.treeCount); });
    $('btnRegenTrees').addEventListener('click', ()=> { scatterTrees(settings.treeCount); });
    $('btnRegenGround').addEventListener('click', ()=> { groundMaterial.diffuseTexture?.dispose(); groundMaterial.diffuseTexture = makeGroundTexture(); });
    $('btnFullscreen').addEventListener('click', async ()=> { try { await (document.documentElement.requestFullscreen?.() || Promise.reject()); } catch {} });
    $('btnApplySeed').addEventListener('click', ()=>{
      const n = Number($('seedBox').value);
      if (Number.isFinite(n) && n>=0 && n<=0xFFFFFFFF) {
        worldState.seed = n>>>0;
        heightSampler = createHeightSampler(worldConfig, worldState.seed);
        groundMaterial.diffuseTexture?.dispose();
        groundMaterial.diffuseTexture = makeGroundTexture();
        scatterTrees(settings.treeCount);
        safeSave(LS_WORLD_KEY, worldState);
        worldStreamer.rebuildActive();
        worldStreamer.update(true);
      }
    });
    $('btnNewSeed').addEventListener('click', ()=>{
      worldState.seed = newSeed();
      $('seedBox').value = String(worldState.seed);
      heightSampler = createHeightSampler(worldConfig, worldState.seed);
      groundMaterial.diffuseTexture?.dispose();
      groundMaterial.diffuseTexture = makeGroundTexture();
      scatterTrees(settings.treeCount);
      safeSave(LS_WORLD_KEY, worldState);
      worldStreamer.rebuildActive();
      worldStreamer.update(true);
    });

    const helpBtn=document.getElementById('helpBtn'); const helpDialog=document.getElementById('helpDialog'); const closeHelp=document.getElementById('closeHelp');
    helpBtn.addEventListener('click',()=>{ helpDialog.style.display='block'; });
    closeHelp.addEventListener('click',()=>{ helpDialog.style.display='none'; });
    window.addEventListener('keydown', e=>{ if(e.key==='Escape') helpDialog.style.display='none'; });

    const testsEl = document.getElementById('tests');
    const tests=[]; const test=(name,fn)=>{ try{ if(fn()===false) throw new Error('assert'); tests.push(['PASS',name]); }catch(e){ tests.push(['FAIL',name,e?.message||String(e)]);} };
    test('Engine live', ()=> typeof BABYLON!=='undefined' && engine && scene && canvas);
    test('UI present', ()=> document.getElementById('optsBtn') && document.getElementById('helpBtn'));
    test('Persistence wired', ()=> localStorage !== undefined);
    test('Streamer active', ()=> worldStreamer && worldStreamer.activeCount() > 0);
    testsEl.textContent = tests.map(t=>`${t[0]} â€” ${t[1]}${t[2]?': '+t[2]:''}`).join('\n');
    console.table(tests);
  });
  </script>
</body>
</html>
